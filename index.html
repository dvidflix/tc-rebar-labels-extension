<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rebar Labels Extension</title>
  <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #f9f9f9; }
    h1 { color: #1a5fb4; }
    button { padding: 10px 16px; margin: 5px; background: #1a5fb4; color: white; border: none; border-radius: 4px; cursor: pointer; }
    button:hover { background: #144a8a; }
    button:disabled { background: #aaa; cursor: not-allowed; }
    textarea { padding: 8px; margin: 10px 0; width: 100%; box-sizing: border-box; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; background: white; }
    th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
    th { background: #1a5fb4; color: white; }
    tr:hover { background: #f0f5ff; cursor: pointer; }
    .selected { background: #d0e4ff !important; }
    .status { margin: 10px 0; font-weight: bold; }
    .good { color: #008000; }
    .error { color: #d00000; }
  </style>
</head>
<body>
  <h1>Rebar Labels Extension</h1>
  <div class="status" id="status">Initializing...</div>

  <label><strong>Label Template</strong> (use {PropertyName} placeholders - exact case!):</label>
  <textarea id="template" rows="3">[ {Serial number} ] Ã˜{Size} L:{Length} mm</textarea>
  <p><small>Detected properties in your model: Serial number, Size, Length, Shape code, Rebar mark, Start Point X/Y, End Point X/Y, etc.<br>Try adding {Rebar mark}, {Shape code}, {Start Point X}, etc.</small></p>

  <button id="refresh">Refresh Rebar Data</button>
  <button id="labelSelected" disabled>Label Selected Group</button>
  <button id="labelAll" disabled>Label All Groups</button>
  <button id="clear" disabled>Clear Labels</button>

  <table id="rebarTable">
    <thead>
      <tr>
        <th>Mark/Serial</th>
        <th>Diameter/Size</th>
        <th>Length</th>
        <th>Qty</th>
        <th>Total Length</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    let tcApi;
    let groups = [];
    let markupIds = [];
    let selectedGroup = null;

    async function init() {
      try {
        tcApi = await TrimbleConnectWorkspace.connect(window.parent);
        document.getElementById('status').textContent = 'Connected! Load your rebar model in the 3D viewer, then click Refresh.';
        document.getElementById('status').classList.add('good');
        document.getElementById('status').classList.remove('error');
      } catch (err) {
        document.getElementById('status').textContent = 'Connection failed: ' + err.message;
        document.getElementById('status').classList.add('error');
        console.error(err);
      }
    }

    async function clearMarkups() {
      for (const id of markupIds) {
        await tcApi.viewer.markup.removeMarkup(id).catch(() => {});
      }
      markupIds = [];
    }

    async function addCallout(anchor, labelPos, text) {
      const arrowId = await tcApi.viewer.markup.addArrowMarkup({
        start: labelPos,
        end: anchor,
        color: { r: 255, g: 255, b: 255 },
        width: 4
      });
      markupIds.push(arrowId);

      const textId = await tcApi.viewer.markup.addTextMarkup({
        text: text,
        position: labelPos,
        color: { r: 0, g: 0, b: 0 },
        backgroundColor: { r: 255, g: 255, b: 255, a: 0.9 },
        fontSize: 36
      });
      markupIds.push(textId);
    }

    async function labelGroup(group, isOnly = false) {
      if (isOnly) await clearMarkups();

      const props = group.sampleProps;
      let text = document.getElementById('template').value;

      // Comprehensive property mapping - add more if needed
      const map = {
        'Serial number': props['Serial number'] || 'N/A',
        'Rebar mark': props['Rebar mark'] || props['Mark'] || '',
        'Size': props['Size'] || '',
        'Length': (props['Length'] || 0).toFixed(0),
        'Shape code': props['Shape code'] || '',
        'Start Point X': props['Start Point X'] || '',
        'Start Point Y': props['Start Point Y'] || '',
        'End Point X': props['End Point X'] || '',
        'End Point Y': props['End Point Y'] || '',
      };

      for (const [key, value] of Object.entries(map)) {
        text = text.replace(new RegExp(`\\{${key}\\}`, 'g'), value || '');
      }

      // Clean up any unfound placeholders
      text = text.replace(/\{[^}]+\}/g, '');

      const bounds = await tcApi.viewer.getObjectBounds(group.objectIds);
      const anchor = {
        x: (bounds.min.x + bounds.max.x) / 2,
        y: (bounds.min.y + bounds.max.y) / 2,
        z: (bounds.min.z + bounds.max.z) / 2
      };
      const labelPos = { x: anchor.x, y: anchor.y + 1.0, z: anchor.z + 2.5 };

      await addCallout(anchor, labelPos, text);
    }

    async function processRebar() {
      await clearMarkups();
      groups = [];
      selectedGroup = null;
      document.getElementById('labelSelected').disabled = true;
      document.getElementById('labelAll').disabled = true;
      document.getElementById('clear').disabled = true;

      const tbody = document.querySelector('#rebarTable tbody');
      tbody.innerHTML = '<tr><td colspan="5">Fetching loaded models...</td></tr>';
      document.getElementById('status').textContent = 'Processing...';
      document.getElementById('status').classList.remove('good', 'error');

      try {
        // Correct way: First get all loaded models, then get objects per model
        const loadedModels = await tcApi.viewer.getLoadedModels ? await tcApi.viewer.getLoadedModels() : [];

        if (loadedModels.length === 0) {
          throw new Error('No models are currently loaded in the 3D viewer. Please load your rebar model first.');
        }

        let allRebar = [];
        for (const model of loadedModels) {
          const modelId = model.id || model.modelId;
          const objects = await tcApi.viewer.getObjects(modelId);

          for (const obj of objects) {
            try {
              const props = await tcApi.model.getProperties(obj.id);
              // Detection based on your exact property names
              if (props['Serial number'] || props['Rebar mark'] || (props['Size'] && props['Length'])) {
                allRebar.push({ id: obj.id, props, modelId });
              }
            } catch (e) {
              // Skip objects with inaccessible properties
            }
          }
        }

        if (allRebar.length === 0) {
          throw new Error('No rebar detected. The model may use slightly different property names or the rebar is not recognized as IfcReinforcingBar. Try selecting one bar and checking its exact property names.');
        }

        // Grouping by Serial number (primary), Size, and Length
        const groupMap = {};
        for (const item of allRebar) {
          const p = item.props;
          const mark = p['Serial number'] || p['Rebar mark'] || 'Unknown';
          const dia = p['Size'] || '';
          const len = Math.round(parseFloat(p['Length']) || 0);
          const key = `${mark}|${dia}|${len}`;

          if (!groupMap[key]) {
            groupMap[key] = {
              mark,
              diameter: dia,
              length: len,
              objectIds: [],
              sampleProps: p
            };
          }
          groupMap[key].objectIds.push(item.id);
        }

        groups = Object.values(groupMap);
        groups.forEach(g => {
          g.quantity = g.objectIds.length;
          g.totalLength = (g.length * g.quantity).toFixed(0);
        });

        // Render table
        tbody.innerHTML = '';
        groups.forEach(group => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${group.mark}</td>
            <td>${group.diameter}</td>
            <td>${group.length}</td>
            <td>${group.quantity}</td>
            <td>${group.totalLength}</td>
          `;
          tr.onclick = async () => {
            document.querySelectorAll('#rebarTable tr').forEach(r => r.classList.remove('selected'));
            tr.classList.add('selected');
            selectedGroup = group;
            document.getElementById('labelSelected').disabled = false;

            await tcApi.viewer.isolate({ objectIds: group.objectIds });
            await tcApi.viewer.zoomTo({ objectIds: group.objectIds });
          };
          tbody.appendChild(tr);
        });

        document.getElementById('labelAll').disabled = false;
        document.getElementById('clear').disabled = false;
        document.getElementById('status').textContent = `Success! Found ${groups.length} groups (${allRebar.length} bars).`;
        document.getElementById('status').classList.add('good');
      } catch (err) {
        tbody.innerHTML = `<tr><td colspan="5">Error: ${err.message}</td></tr>`;
        document.getElementById('status').textContent = 'Failed: ' + err.message;
        document.getElementById('status').classList.add('error');
        console.error(err);
      }
    }

    document.getElementById('refresh').onclick = processRebar;
    document.getElementById('clear').onclick = clearMarkups;
    document.getElementById('labelSelected').onclick = () => selectedGroup && labelGroup(selectedGroup, true);
    document.getElementById('labelAll').onclick = async () => {
      await clearMarkups();
      for (const g of groups) await labelGroup(g);
    };

    init();
  </script>
</body>
</html>